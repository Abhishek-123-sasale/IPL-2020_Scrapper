import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _regeneratorRuntime from "@babel/runtime/regenerator";

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

import fs from 'fs';
import path from 'path';
import os from 'os';
import Archive from './archive';
import generateWorkbookXml from './statics/workbook.xml';
import generateWorkbookXmlRels from './statics/workbook.xml.rels';
import rels from './statics/rels';
import contentTypes from './statics/[Content_Types].xml';
import { generateSheets } from './writeXlsxFile.common';
export default function writeXlsxFile(_x) {
  return _writeXlsxFile.apply(this, arguments);
}

function _writeXlsxFile() {
  _writeXlsxFile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(data) {
    var _ref,
        filePath,
        sheetNames,
        schema,
        columns,
        headerStyle,
        fontFamily,
        fontSize,
        dateFormat,
        archive,
        _generateSheets,
        sheets,
        getSharedStringsXml,
        getStylesXml,
        root,
        xl,
        _rels,
        worksheetsPath,
        promises,
        _iterator,
        _step,
        _step$value,
        id,
        _data,
        _args = arguments;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _ref = _args.length > 1 && _args[1] !== undefined ? _args[1] : {}, filePath = _ref.filePath, sheetNames = _ref.sheets, schema = _ref.schema, columns = _ref.columns, headerStyle = _ref.headerStyle, fontFamily = _ref.fontFamily, fontSize = _ref.fontSize, dateFormat = _ref.dateFormat;
            archive = new Archive(filePath);
            _generateSheets = generateSheets({
              data: data,
              sheetNames: sheetNames,
              schema: schema,
              columns: columns,
              headerStyle: headerStyle,
              fontFamily: fontFamily,
              fontSize: fontSize,
              dateFormat: dateFormat
            }), sheets = _generateSheets.sheets, getSharedStringsXml = _generateSheets.getSharedStringsXml, getStylesXml = _generateSheets.getStylesXml; // There doesn't seem to be a way to just append a file into a subdirectory
            // in `archiver` library, hence using a hacky temporary directory workaround.
            // https://www.npmjs.com/package/archiver

            _context.next = 5;
            return createTempDirectory();

          case 5:
            root = _context.sent;
            _context.next = 8;
            return createDirectory(path.join(root, 'xl'));

          case 8:
            xl = _context.sent;
            _context.next = 11;
            return createDirectory(path.join(xl, '_rels'));

          case 11:
            _rels = _context.sent;
            _context.next = 14;
            return createDirectory(path.join(xl, 'worksheets'));

          case 14:
            worksheetsPath = _context.sent;
            promises = [writeFile(path.join(_rels, 'workbook.xml.rels'), generateWorkbookXmlRels({
              sheets: sheets
            })), writeFile(path.join(xl, 'workbook.xml'), generateWorkbookXml({
              sheets: sheets
            })), writeFile(path.join(xl, 'styles.xml'), getStylesXml()), writeFile(path.join(xl, 'sharedStrings.xml'), getSharedStringsXml())];

            for (_iterator = _createForOfIteratorHelperLoose(sheets); !(_step = _iterator()).done;) {
              _step$value = _step.value, id = _step$value.id, _data = _step$value.data;
              promises.push(writeFile(path.join(worksheetsPath, "sheet".concat(id, ".xml")), _data));
            }

            _context.next = 19;
            return Promise.all(promises);

          case 19:
            archive.directory(xl, 'xl');
            archive.append(rels, '_rels/.rels');
            archive.append(contentTypes, '[Content_Types].xml');

            if (!filePath) {
              _context.next = 29;
              break;
            }

            _context.next = 25;
            return archive.write();

          case 25:
            _context.next = 27;
            return removeDirectory(root);

          case 27:
            _context.next = 30;
            break;

          case 29:
            return _context.abrupt("return", archive.write());

          case 30:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _writeXlsxFile.apply(this, arguments);
}

function writeFile(path, contents) {
  return new Promise(function (resolve, reject) {
    fs.writeFile(path, contents, 'utf-8', function (error) {
      if (error) {
        return reject(error);
      }

      resolve();
    });
  });
}

function createDirectory(path) {
  return new Promise(function (resolve, reject) {
    fs.mkdir(path, function (error) {
      if (error) {
        return reject(error);
      }

      resolve(path);
    });
  });
}

function createTempDirectory() {
  return new Promise(function (resolve, reject) {
    fs.mkdtemp(path.join(os.tmpdir(), 'write-excel-file-'), function (error, directoryPath) {
      if (error) {
        return reject(error);
      }

      resolve(directoryPath);
    });
  });
}

function removeDirectory(path) {
  return new Promise(function (resolve, reject) {
    fs.rmdir(path, {
      recursive: true
    }, function (error) {
      if (error) {
        return reject(error);
      }

      resolve(path);
    });
  });
}
//# sourceMappingURL=writeXlsxFileNode.js.map